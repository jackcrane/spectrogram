<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Canvas Spectrogram (Draw + Hear)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #06080c;
        color: #e6edf3;
        font-family: system-ui, sans-serif;
        user-select: none;
        overscroll-behavior: none;
        -webkit-user-select: none;
      }

      .wrap {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 10px;
        padding: 12px;
        box-sizing: border-box;
      }

      .bar {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: black;
        touch-action: none;
      }

      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      .hint {
        opacity: 0.75;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="bar">
        <select id="samples">
          <option value="">— samples —</option>
          <option value="curiosity-killed-the-cat.mp3">
            curiosity-killed-the-cat
          </option>
          <option value="supercalifragilistic.mp3">supercalifragilistic</option>
          <option value="world.mp3">world</option>
        </select>

        <input
          id="file"
          type="file"
          accept="audio/mpeg,audio/mp3,audio/wav,audio/*"
        />

        <select id="maxfreq">
          <option value="3000">3 kHz</option>
          <option value="5000">5 kHz</option>
          <option value="7000" selected>7 kHz</option>
          <option value="10000">10 kHz</option>
          <option value="16000">16 kHz</option>
        </select>

        <button id="render" disabled>Render Spectrogram</button>

        <button id="play" disabled>Play (what you drew)</button>
        <button id="pause" disabled>Pause</button>
        <button id="stop" disabled>Stop</button>

        <button id="clear" disabled>Clear Drawing</button>

        <span id="status" class="mono"></span>
        <span id="time" class="mono"></span>
        <span class="hint mono">Left=draw RED, Right=erase</span>
      </div>

      <canvas id="canvas"></canvas>
    </div>

    <script type="module">
      // ---------------- utilities ----------------

      const clamp = (x, a, b) => Math.min(b, Math.max(a, x));

      const formatSec = (s) => {
        if (!Number.isFinite(s)) return "—";
        const m = Math.floor(s / 60);
        const r = s - m * 60;
        return `${m}:${r.toFixed(2).padStart(5, "0")}`;
      };

      const colorMap = (t) => {
        t = clamp(t, 0, 1);
        const stops = [
          [0.0, [0, 0, 0]],
          [0.25, [32, 0, 64]],
          [0.5, [0, 120, 200]],
          [0.75, [240, 220, 80]],
          [1.0, [255, 255, 255]],
        ];
        for (let i = 0; i < stops.length - 1; i++) {
          const [t0, c0] = stops[i];
          const [t1, c1] = stops[i + 1];
          if (t >= t0 && t <= t1) {
            const u = (t - t0) / (t1 - t0);
            return c0.map((v, j) => Math.round(v + (c1[j] - v) * u));
          }
        }
        return [0, 0, 0];
      };

      const resizeCanvasToCSS = (canvas) => {
        const dpr = window.devicePixelRatio || 1;
        const w = Math.max(1, Math.floor(canvas.clientWidth * dpr));
        const h = Math.max(1, Math.floor(canvas.clientHeight * dpr));
        if (canvas.width !== w) canvas.width = w;
        if (canvas.height !== h) canvas.height = h;
        return { dpr, w, h };
      };

      // ---------------- window ----------------

      const hann = (N) => {
        const w = new Float32Array(N);
        for (let i = 0; i < N; i++)
          w[i] = 0.5 - 0.5 * Math.cos((2 * Math.PI * i) / (N - 1));
        return w;
      };

      // ---------------- FFT (in-place complex) ----------------
      // Cooley–Tukey radix-2. re/im length must be power-of-2.

      const bitReversePermute = (re, im) => {
        const N = re.length;
        for (let i = 1, j = 0; i < N; i++) {
          let bit = N >> 1;
          for (; j & bit; bit >>= 1) j ^= bit;
          j ^= bit;
          if (i < j) {
            [re[i], re[j]] = [re[j], re[i]];
            [im[i], im[j]] = [im[j], im[i]];
          }
        }
      };

      const fftInPlace = (re, im, inverse = false) => {
        const N = re.length;
        bitReversePermute(re, im);

        for (let len = 2; len <= N; len <<= 1) {
          const ang = ((inverse ? 2 : -2) * Math.PI) / len;
          const wlenRe = Math.cos(ang);
          const wlenIm = Math.sin(ang);

          for (let i = 0; i < N; i += len) {
            let wRe = 1;
            let wIm = 0;
            const half = len >> 1;

            for (let j = 0; j < half; j++) {
              const uRe = re[i + j];
              const uIm = im[i + j];

              const vRe = re[i + j + half] * wRe - im[i + j + half] * wIm;
              const vIm = re[i + j + half] * wIm + im[i + j + half] * wRe;

              re[i + j] = uRe + vRe;
              im[i + j] = uIm + vIm;
              re[i + j + half] = uRe - vRe;
              im[i + j + half] = uIm - vIm;

              const nRe = wRe * wlenRe - wIm * wlenIm;
              wIm = wRe * wlenIm + wIm * wlenRe;
              wRe = nRe;
            }
          }
        }

        if (inverse) {
          const invN = 1 / N;
          for (let i = 0; i < N; i++) {
            re[i] *= invN;
            im[i] *= invN;
          }
        }
      };

      // ---------------- spectrogram (analysis only) ----------------

      const computeSpectrogram = ({
        samples,
        sampleRate,
        winSize,
        hopSize,
        maxFreqHz,
        dbRange,
      }) => {
        const window = hann(winSize);
        const nyquist = sampleRate / 2;
        const maxBin = Math.min(
          winSize / 2,
          Math.floor((maxFreqHz / nyquist) * (winSize / 2))
        );

        const frames = Math.max(
          0,
          Math.floor((samples.length - winSize) / hopSize) + 1
        );

        const data = new Array(frames);
        let maxDb = -Infinity;

        const re = new Float32Array(winSize);
        const im = new Float32Array(winSize);

        for (let f = 0; f < frames; f++) {
          const start = f * hopSize;

          re.fill(0);
          im.fill(0);

          for (let i = 0; i < winSize; i++) {
            re[i] = (samples[start + i] || 0) * window[i];
          }

          fftInPlace(re, im, false);

          const row = new Float32Array(maxBin);
          for (let b = 0; b < maxBin; b++) {
            const mag = Math.hypot(re[b], im[b]);
            const db = 20 * Math.log10(mag / winSize + 1e-12);
            row[b] = db;
            if (db > maxDb) maxDb = db;
          }
          data[f] = row;
        }

        const floorDb = maxDb - dbRange;

        return {
          data,
          frames,
          bins: maxBin,
          maxDb,
          floorDb,
          sampleRate,
          hopSize,
          winSize,
          durationSec: samples.length / sampleRate,
        };
      };

      // ---------------- rendering ----------------

      const makeSpectrogramBitmap = (spec) => {
        const { data, frames, bins, maxDb, floorDb } = spec;

        const img = new ImageData(frames, bins);
        const out = img.data;

        for (let x = 0; x < frames; x++) {
          const col = data[x];
          for (let y = 0; y < bins; y++) {
            const db = col[bins - 1 - y]; // low freq bottom
            const t = (db - floorDb) / (maxDb - floorDb);
            const [r, g, b] = colorMap(t);
            const i = (y * frames + x) * 4;
            out[i] = r;
            out[i + 1] = g;
            out[i + 2] = b;
            out[i + 3] = 255;
          }
        }

        const off = document.createElement("canvas");
        off.width = frames;
        off.height = bins;
        off.getContext("2d").putImageData(img, 0, 0);
        return off;
      };

      // ---------------- audio player (buffer source) ----------------

      class AudioPlayer {
        constructor() {
          this.ctx = null;
          this.buffer = null;

          this.source = null;
          this.gain = null;

          this.startedAt = 0;
          this.offsetSec = 0;
          this.state = "stopped";
        }

        async ensureContext() {
          if (!this.ctx)
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          if (this.ctx.state === "suspended") await this.ctx.resume();
          if (!this.gain) {
            this.gain = this.ctx.createGain();
            this.gain.gain.value = 1.0;
            this.gain.connect(this.ctx.destination);
          }
        }

        setBuffer(buffer) {
          this.buffer = buffer;
          this.stop();
        }

        _makeSource() {
          const s = this.ctx.createBufferSource();
          s.buffer = this.buffer;
          s.connect(this.gain);
          s.onended = () => {
            if (
              this.state === "playing" &&
              this.currentTimeSec() >= this.durationSec() - 0.02
            ) {
              this.state = "stopped";
              this.offsetSec = 0;
            }
          };
          return s;
        }

        durationSec() {
          return this.buffer ? this.buffer.duration : 0;
        }

        currentTimeSec() {
          if (!this.ctx) return 0;
          if (this.state === "playing") {
            return clamp(
              this.offsetSec + (this.ctx.currentTime - this.startedAt),
              0,
              this.durationSec()
            );
          }
          return clamp(this.offsetSec, 0, this.durationSec());
        }

        async play() {
          if (!this.buffer) return;
          await this.ensureContext();
          if (this.state === "playing") return;

          this.source = this._makeSource();
          this.startedAt = this.ctx.currentTime;
          this.source.start(0, this.offsetSec);
          this.state = "playing";
        }

        pause() {
          if (this.state !== "playing") return;
          this.offsetSec = this.currentTimeSec();
          this._stopSourceOnly();
          this.state = "paused";
        }

        stop() {
          this.offsetSec = 0;
          this._stopSourceOnly();
          this.state = "stopped";
        }

        _stopSourceOnly() {
          if (!this.source) return;
          try {
            this.source.onended = null;
            this.source.stop();
          } catch {}
          try {
            this.source.disconnect();
          } catch {}
          this.source = null;
        }
      }

      // ---------------- app state ----------------

      const els = {
        file: document.getElementById("file"),
        samples: document.getElementById("samples"),
        maxfreq: document.getElementById("maxfreq"),
        render: document.getElementById("render"),
        play: document.getElementById("play"),
        pause: document.getElementById("pause"),
        stop: document.getElementById("stop"),
        clear: document.getElementById("clear"),
        status: document.getElementById("status"),
        time: document.getElementById("time"),
        canvas: document.getElementById("canvas"),
      };

      let MAX_FREQ_HZ = Number(els.maxfreq.value);

      let lastFx = null;
      let lastBy = null;

      els.maxfreq.addEventListener("change", () => {
        MAX_FREQ_HZ = Number(els.maxfreq.value);
        setStatus("max frequency changed – re-render required");
        setButtons(false);
        els.render.disabled = false;
      });

      els.samples.addEventListener("change", async () => {
        const name = els.samples.value;
        if (!name) return;

        setStatus("loading sample…");
        setButtons(false);

        try {
          const res = await fetch(name);
          const blob = await res.blob();
          const file = new File([blob], name, { type: blob.type });

          decoded = await decodeAudioFile(file);

          spec = null;
          bitmap = null;
          drawMask = null;
          maskCanvas = null;
          maskCtx = null;
          player.stop();

          setStatus(
            `ready (${decoded.sampleRate} Hz, ${formatSec(
              decoded.buffer.duration
            )})`
          );
          els.render.disabled = false;
        } catch (e) {
          console.error(e);
          setStatus("sample load failed");
        }
      });

      const player = new AudioPlayer();

      let decoded = null; // { buffer, mono, sampleRate }
      let spec = null;
      let bitmap = null;

      // mask: 0..1, per [frame][bin]
      let drawMask = null;

      // red overlay (no opacity)
      let maskCanvas = null;
      let maskCtx = null;

      const WIN_SIZE = 4096;
      const HOP_SIZE = 512;
      const DB_RANGE = 80;

      const setStatus = (t) => (els.status.textContent = t);

      const decodeAudioFile = async (file) => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = await ctx.decodeAudioData(await file.arrayBuffer());

        const mono = new Float32Array(buffer.length);
        for (let c = 0; c < buffer.numberOfChannels; c++) {
          const d = buffer.getChannelData(c);
          for (let i = 0; i < d.length; i++)
            mono[i] += d[i] / buffer.numberOfChannels;
        }

        return { buffer, mono, sampleRate: buffer.sampleRate };
      };

      const initMask = (spec) => {
        drawMask = Array.from({ length: spec.frames }, () =>
          new Float32Array(spec.bins).fill(0)
        );

        maskCanvas = document.createElement("canvas");
        maskCanvas.width = spec.frames;
        maskCanvas.height = spec.bins;
        maskCtx = maskCanvas.getContext("2d", { willReadFrequently: false });
        maskCtx.imageSmoothingEnabled = false;
        maskCtx.clearRect(0, 0, spec.frames, spec.bins);
      };

      const clearMask = () => {
        if (!drawMask || !maskCtx || !spec) return;
        for (let x = 0; x < spec.frames; x++) drawMask[x].fill(0);
        maskCtx.clearRect(0, 0, spec.frames, spec.bins);
      };

      // canvas->spec coords (frame x, bin y)
      const canvasToSpec = (clientX, clientY) => {
        const rect = els.canvas.getBoundingClientRect();
        const xCss = clientX - rect.left;
        const yCss = clientY - rect.top;

        const fx = clamp(
          Math.floor((xCss / rect.width) * spec.frames),
          0,
          spec.frames - 1
        );
        const byTop = clamp(
          Math.floor((yCss / rect.height) * spec.bins),
          0,
          spec.bins - 1
        );
        const bin = spec.bins - 1 - byTop; // bottom is low freq
        return [fx, bin];
      };

      const paintCell = (frameX, binY, value01) => {
        if (!drawMask || !maskCtx || !spec) return;

        drawMask[frameX][binY] = value01;

        const cy = spec.bins - 1 - binY; // maskCanvas y=0 is top
        if (value01 >= 0.5) {
          maskCtx.fillStyle = "rgba(255,0,0,1)"; // RED, no opacity
          maskCtx.fillRect(frameX, cy, 1, 1);
        } else {
          maskCtx.clearRect(frameX, cy, 1, 1);
        }
      };

      const paintLine = (x0, y0, x1, y1, value01) => {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        let x = x0;
        let y = y0;

        while (true) {
          paintCell(x, y, value01);
          if (x === x1 && y === y1) break;
          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            y += sy;
          }
        }
      };

      // ---------------- masked resynthesis ----------------
      // Builds an AudioBuffer where only the drawn regions are audible.
      // FIX: proper overlap-add normalization (no tiny volume).

      const resynthesizeMasked = async () => {
        if (!decoded || !spec || !drawMask) return null;

        await player.ensureContext();

        const { mono, sampleRate } = decoded;
        const outBuf = player.ctx.createBuffer(1, mono.length, sampleRate);
        const out = outBuf.getChannelData(0);

        const window = hann(WIN_SIZE);
        const norm = new Float32Array(out.length);

        const re = new Float32Array(WIN_SIZE);
        const im = new Float32Array(WIN_SIZE);

        const hop = HOP_SIZE;

        for (let f = 0; f < spec.frames; f++) {
          const start = f * hop;

          re.fill(0);
          im.fill(0);

          for (let i = 0; i < WIN_SIZE; i++) {
            re[i] = (mono[start + i] || 0) * window[i];
          }

          fftInPlace(re, im, false);

          // Only keep drawn bins up to spec.bins, and also zero everything above it
          // (so you don't accidentally hear unmasked high frequencies).
          const maxBin = spec.bins;

          // DC..Nyquist half
          for (let b = 0; b <= WIN_SIZE / 2; b++) {
            const m = b < maxBin ? drawMask[f][b] : 0;
            re[b] *= m;
            im[b] *= m;

            if (b !== 0 && b !== WIN_SIZE / 2) {
              const mb = WIN_SIZE - b;
              re[mb] *= m;
              im[mb] *= m;
            }
          }

          fftInPlace(re, im, true);

          for (let i = 0; i < WIN_SIZE; i++) {
            const idx = start + i;
            if (idx >= out.length) break;
            const w = window[i];
            out[idx] += re[i] * w;
            norm[idx] += w * w;
          }
        }

        for (let i = 0; i < out.length; i++) {
          const n = norm[i];
          out[i] = n > 1e-8 ? out[i] / n : 0;
        }

        return outBuf;
      };

      // ---------------- draw loop ----------------

      const draw = () => {
        const ctx = els.canvas.getContext("2d");
        const { w, h } = resizeCanvasToCSS(els.canvas);

        ctx.clearRect(0, 0, w, h);

        if (bitmap) {
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(bitmap, 0, 0, w, h);
        }

        if (maskCanvas) {
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.globalAlpha = 1; // NO OPACITY
          ctx.drawImage(maskCanvas, 0, 0, w, h);
          ctx.restore();
        }

        // playback cursor
        if (spec && player.state === "playing") {
          const t = player.currentTimeSec();
          const x = (t / spec.durationSec) * w;

          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,0.85)";
          ctx.lineWidth = Math.max(1, Math.floor(window.devicePixelRatio || 1));
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
          ctx.restore();
        }

        if (spec) {
          const t = player.currentTimeSec();
          els.time.textContent = `${formatSec(t)} / ${formatSec(spec.durationSec)}`;
        } else {
          els.time.textContent = "";
        }
      };

      const tick = () => {
        draw();
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);

      window.addEventListener("resize", () => draw(), { passive: true });

      // ---------------- UI wiring ----------------

      const setButtons = (ready) => {
        els.render.disabled = !ready;
        els.play.disabled = !ready;
        els.pause.disabled = !ready;
        els.stop.disabled = !ready;
        els.clear.disabled = !ready;
      };

      els.file.addEventListener("change", async () => {
        const file = els.file.files?.[0];
        if (!file) return;

        setStatus("decoding…");
        setButtons(false);

        spec = null;
        bitmap = null;
        decoded = null;
        drawMask = null;
        maskCanvas = null;
        maskCtx = null;

        player.stop();

        try {
          decoded = await decodeAudioFile(file);
          setStatus(
            `ready (${decoded.sampleRate} Hz, ${formatSec(decoded.buffer.duration)})`
          );
          els.render.disabled = false;
        } catch (e) {
          console.error(e);
          setStatus("decode failed");
        }
      });

      els.render.addEventListener("click", async () => {
        if (!decoded) return;

        setStatus("rendering spectrogram…");
        els.render.disabled = true;
        setButtons(false);

        player.stop();
        bitmap = null;
        spec = null;
        drawMask = null;
        maskCanvas = null;
        maskCtx = null;

        await new Promise((r) => setTimeout(r, 0));

        try {
          spec = computeSpectrogram({
            samples: decoded.mono,
            sampleRate: decoded.sampleRate,
            winSize: WIN_SIZE,
            hopSize: HOP_SIZE,
            maxFreqHz: MAX_FREQ_HZ,
            dbRange: DB_RANGE,
          });

          bitmap = makeSpectrogramBitmap(spec);
          initMask(spec);

          setStatus("spectrogram ready (draw RED to hear; erase to remove)");
          setButtons(true);
        } catch (e) {
          console.error(e);
          setStatus("render failed");
          setButtons(false);
        } finally {
          els.render.disabled = false;
        }
      });

      els.clear.addEventListener("click", () => {
        clearMask();
        setStatus("cleared");
      });

      els.play.addEventListener("click", async () => {
        if (!decoded || !spec || !drawMask) return;

        setStatus("building audio from drawing…");
        els.play.disabled = true;

        try {
          const maskedBuffer = await resynthesizeMasked();
          if (!maskedBuffer) {
            setStatus("failed to build audio");
            return;
          }
          player.setBuffer(maskedBuffer);

          setStatus("playing");
          await player.play();
        } catch (e) {
          console.error(e);
          setStatus("play failed");
        } finally {
          els.play.disabled = false;
        }
      });

      els.pause.addEventListener("click", () => {
        player.pause();
        setStatus("paused");
        draw();
      });

      els.stop.addEventListener("click", () => {
        player.stop();
        setStatus("stopped");
        draw();
      });

      // ---------------- drawing interactions ----------------

      let drawing = false;
      let drawValue = 1; // 1 draw, 0 erase

      els.canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      els.canvas.addEventListener("pointerdown", (e) => {
        if (!spec || !drawMask) return;
        drawing = true;
        drawValue = e.button === 2 ? 0 : 1;
        els.canvas.setPointerCapture(e.pointerId);

        const [fx, by] = canvasToSpec(e.clientX, e.clientY);
        lastFx = fx;
        lastBy = by;
        paintCell(fx, by, drawValue);
      });

      els.canvas.addEventListener("pointermove", (e) => {
        if (!drawing || !spec || !drawMask) return;
        const [fx, by] = canvasToSpec(e.clientX, e.clientY);

        if (lastFx !== null) {
          paintLine(lastFx, lastBy, fx, by, drawValue);
        }

        lastFx = fx;
        lastBy = by;
      });
      const endDraw = () => {
        drawing = false;
        lastFx = null;
        lastBy = null;
      };

      els.canvas.addEventListener("pointerup", endDraw);
      els.canvas.addEventListener("pointercancel", endDraw);
      els.canvas.addEventListener("pointerleave", endDraw);

      // initial
      setStatus("load an audio file");
      setButtons(false);
    </script>
  </body>
</html>
